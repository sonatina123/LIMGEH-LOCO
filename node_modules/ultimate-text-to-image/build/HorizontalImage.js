"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HorizontalImage = void 0;
const canvas_1 = require("canvas");
const BaseClass_1 = require("./BaseClass");
const canvas_2 = require("./utils/canvas");
class HorizontalImage extends BaseClass_1.BaseClass {
    constructor(ultimateTextToImages, options = {}, renderOptions = {}) {
        super();
        this.ultimateTextToImages = ultimateTextToImages;
        this.options = options;
        this.renderOptions = renderOptions;
    }
    render() {
        this._startTimer();
        const { backgroundColor } = this.options;
        const margin = this.options.margin || 0;
        for (const ultimateTextToImage of this.ultimateTextToImages) {
            ultimateTextToImage.render();
        }
        const width = this.ultimateTextToImages.reduce((a, b) => a + b.width, 0) + margin * 2;
        const height = this.ultimateTextToImages
            .reduce((a, b) => Math.max(a, b.height), 0) + margin * 2;
        this._canvas = new canvas_1.Canvas(width, height);
        const ctx = this._canvas.getContext("2d");
        // hook
        canvas_2.renderHook(this._canvas, this.renderOptions.preRender);
        // draw background
        canvas_2.drawBackgroundColor(ctx, { color: backgroundColor });
        let x = margin;
        let y = 0;
        for (const ultimateTextToImage of this.ultimateTextToImages) {
            let valign = this.options.valign;
            if (ultimateTextToImage.options.nestedValign) {
                valign = ultimateTextToImage.options.nestedValign;
            }
            if (valign === "bottom") {
                y = height - ultimateTextToImage.height - margin;
            }
            else if (valign === "middle") {
                y = (height - ultimateTextToImage.height) / 2;
            }
            else {
                y = margin;
            }
            ctx.drawImage(ultimateTextToImage.canvas, x, y);
            x += ultimateTextToImage.width;
        }
        // hook
        canvas_2.renderHook(this._canvas, this.renderOptions.posRender);
        this._endTimer();
        return this;
    }
}
exports.HorizontalImage = HorizontalImage;
